<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Neon Finger Balance Pro</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; background: #050505; color: #fff; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { display: block; filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.5)); }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
                   display: flex; flex-direction: column; justify-content: space-between; padding: 30px; box-sizing: border-box; }
        .stats { font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #0ff; }
        #msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
               font-size: 48px; color: #0ff; text-align: center; text-shadow: 0 0 20px #0ff; display: none; }
        .guide { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); opacity: 0.7; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="overlay">
        <div class="stats">
            <div>TIME: <span id="time">0.00</span>s</div>
            <div>BEST: <span id="best">0.00</span>s</div>
        </div>
        <div id="msg">READY?</div>
        <div class="guide">人差し指をカメラに向けて開始</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const timeDisplay = document.getElementById('time');
        const bestDisplay = document.getElementById('best');
        const msgDisplay = document.getElementById('msg');

        let width, height;
        let fingerX = 0, fingerY = 0, lastFingerX = 0;
        let poleAngle = 0, poleVel = 0;
        let score = 0, bestScore = localStorage.getItem('bestScore') || 0;
        let active = false;
        let particles = [];

        bestDisplay.innerText = bestScore;

        // --- 物理パラメータ ---
        const config = {
            gravity: 0.006,
            friction: 0.985,
            length: 280,
            difficultyScale: 0.0001 // 時間とともに難しくなる
        };

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- パーティクルシステム ---
        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.alpha = 1;
            }
            draw() {
                ctx.strokeStyle = `rgba(0, 255, 255, ${this.alpha})`;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.vx, this.y + this.vy);
                ctx.stroke();
                this.x += this.vx; this.y += this.vy;
                this.alpha -= 0.02;
            }
        }

        // --- AI 手検出設定 ---
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
        hands.onResults(results => {
            if (results.multiHandLandmarks?.length > 0) {
                const tip = results.multiHandLandmarks[0][8];
                fingerX = (1 - tip.x) * width;
                fingerY = tip.y * height;
                if (!active) startGame();
            } else {
                if (active) gameOver();
            }
        });

        const camera = new Camera(document.createElement('video'), {
            onFrame: async () => await hands.send({image: camera.video}),
            width: 1280, height: 720
        });
        camera.start();

        function startGame() {
            active = true;
            score = 0;
            poleAngle = (Math.random() - 0.5) * 0.2;
            poleVel = 0;
            msgDisplay.style.display = 'none';
        }

        function gameOver() {
            if (!active) return;
            active = false;
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('bestScore', bestScore);
                bestDisplay.innerText = bestScore;
            }
            msgDisplay.innerText = "GAME OVER\n" + score + "s";
            msgDisplay.style.display = 'block';
        }

        function draw() {
            ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; // 残像エフェクト
            ctx.fillRect(0, 0, width, height);

            if (active) {
                score = ((performance.now() - startTime) / 1000).toFixed(2);
                if (isNaN(score)) startTime = performance.now();
                timeDisplay.innerText = score;

                // 物理演算
                let currentGravity = config.gravity + (score * config.difficultyScale);
                poleVel += Math.sin(poleAngle) * currentGravity;
                poleVel -= (fingerX - lastFingerX) * 0.0015;
                poleVel *= config.friction;
                poleAngle += poleVel;
                lastFingerX = fingerX;

                if (Math.abs(poleAngle) > Math.PI / 2.2) gameOver();

                // 棒の描画
                const ex = fingerX + Math.sin(poleAngle) * config.length;
                const ey = fingerY - Math.cos(poleAngle) * config.length;

                ctx.shadowBlur = 15;
                ctx.shadowColor = '#0ff';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(fingerX, fingerY);
                ctx.lineTo(ex, ey);
                ctx.stroke();

                // 先端の装飾
                ctx.fillStyle = '#f0f';
                ctx.beginPath();
                ctx.arc(ex, ey, 8, 0, Math.PI * 2);
                ctx.fill();

                // パーティクル生成
                if (Math.abs(poleVel) > 0.05) particles.push(new Particle(ex, ey));
            }

            // 指先の表示
            ctx.shadowBlur = 20;
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(fingerX, fingerY, 20, 0, Math.PI * 2);
            ctx.stroke();

            // パーティクル更新
            particles = particles.filter(p => p.alpha > 0);
            particles.forEach(p => p.draw());

            requestAnimationFrame(draw);
        }

        let startTime = performance.now();
        draw();
    </script>
</body>
</html>
